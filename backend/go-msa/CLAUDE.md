본 문서는 프레임워크에 의존하지 않고 순수 Golang을 사용하여 확장 가능하고 유지보수하기 쉬운 마이크로서비스 시스템을 구축하기 위한 핵심 설계 원칙과 구체적인 구현 전략을 종합적으로 정리합니다.

## 1. 고수준 아키텍처 설계 (High-Level Architecture)

시스템은 명확한 책임 분리를 위해 API 게이트웨이, 인증 서버, 그리고 다수의 비즈니스 서버로 구성됩니다.

### 1.1. 핵심 컴포넌트 및 역할

- **API 게이트웨이 (API Gateway):**
  - **역할:** 시스템의 유일한 진입점(Single Entry Point)
  - **책임:**
    - **리버스 프록시 및 라우팅:** `net/http/httputil`을 사용하여 들어오는 모든 요청을 적절한 내부 마이크로서비스로 전달합니다.
    - **횡단 관심사 처리 (Cross-Cutting Concerns):** 인증, 인가, 로깅, 속도 제한(Rate Limiting), 캐싱과 같은 공통 기능을 중앙에서 처리하여 개별 서비스의 부담을 줄입니다.
    - **추상화:** 내부 서비스의 복잡한 구조를 외부로부터 숨겨 클라이언트와 서비스를 분리(Decoupling)합니다.
- **인증 서버 (Authentication Server):**
  - **역할:** 시스템의 모든 인증 및 인가 책임을 전담하는 보안 관문.
  - **책임:**
    - 사용자 회원가입 및 로그인 처리.
    - 안전한 비밀번호 해싱 (`bcrypt` 사용).
    - JWT(Access/Refresh Token) 발급 및 서명.
    - 토큰 갱신 및 로그아웃(토큰 무효화) 처리.
- **비즈니스 서버 (Business Servers):**
  - **역할:** 상품, 주문, 결제 등 애플리케이션의 실제 비즈니스 로직을 수행하는 서비스.
  - **책임:**
    - 자신의 도메인에 대한 핵심 로직 수행.
    - API 게이트웨이가 검증하고 전달해 준 사용자 정보를 신뢰하고 비즈니스 로직에 활용.
    - 자신만의 데이터베이스를 소유하고 관리.

### 1.2. 주요 통신 흐름

1. **사용자 로그인 흐름:**
   - `Client` → `API Gateway`: 로그인 정보(ID/PW) 전달.
   - `API Gateway` → `Auth Server`: 요청을 그대로 프록시.
   - `Auth Server`: 자격 증명 검증 후 JWT(Access/Refresh Token) 생성 및 서명.
   - `Auth Server` → `API Gateway` → `Client`: 생성된 토큰 반환.
2. **인증된 API 호출 흐름:**
   - `Client` → `API Gateway`: `Authorization: Bearer <Access_Token>` 헤더와 함께 비즈니스 API 요청.
   - `API Gateway`:
     - **(1단계) 블랙리스트 확인:** Redis에 저장된 블랙리스트를 조회하여 무효화된 토큰인지 확인.
     - **(2단계) JWT 검증:** JWKS 엔드포인트를 통해 가져온 공개키로 토큰의 서명, 만료 시간(`exp`), 발급자(`iss`) 등을 검증.
     - **(3단계) 요청 변환:** 검증 성공 시, `Authorization` 헤더를 제거하고, 토큰에서 추출한 사용자 정보를 `X-Authenticated-User-ID`와 같은 신뢰할 수 있는 내부 헤더에 담아 요청을 변환.
   - `API Gateway` → `Business Server`: 변환된 요청을 프록시.
   - `Business Server`: JWT 검증 로직 없이, 게이트웨이가 추가한 헤더를 신뢰하고 비즈니스 로직 수행.

## 2. 폴더 및 코드 구조 관리

코드의 유지보수성과 테스트 용이성을 극대화하기 위해 명확한 레이어 구조와 중앙화된 API 정의 관리를 채택합니다.

### 2.1. 서비스 내부 레이어 구조 (Layered Architecture)

클린 아키텍처의 의존성 규칙에 기반한 실용적인 4-Tier 구조를 적용합니다.

- **`internal/domain`:**
  - **책임:** 핵심 도메인 모델(Struct)과 Repository 인터페이스 정의.
  - **특징:** 외부 의존성 제로. 순수 Go 코드로만 구성.
- **`internal/service`:**
  - **책임:** 비즈니스 로직과 유스케이스 구현.
  - **의존성:** `domain`의 Repository 인터페이스에만 의존.
- **`internal/repository`:**
  - **책임:** `domain`의 Repository 인터페이스에 대한 구체적인 구현. (예: PostgreSQL 연동 로직)
  - **특징:** 데이터베이스 드라이버 등 인프라 기술에 의존.
- **`internal/handler`:**
  - **책임:** HTTP/gRPC 요청 처리, 데이터 파싱 및 응답 생성.
  - **의존성:** `service` 레이어를 호출하여 비즈니스 로직 위임.
- **`cmd/api/main.go`:**
  - **책임:** 애플리케이션의 시작점. 모든 레이어의 인스턴스를 생성하고 의존성을 주입(Dependency Injection)하는 역할.

### 2.2. gRPC Proto 파일 관리 (`.proto` Management)

- **원칙: 중앙 Proto 리포지토리 (Central Proto Repository)**
  - 모든 서비스의 `.proto` 파일은 **별도의 전용 Git 리포지토리**에서 통합 관리합니다. 이는 API 계약(Contract)의 **단일 진실 공급원(Single Source of Truth)** 역할을 합니다.
  - 각 서비스는 이 중앙 리포지토리를 직접 의존하지 않습니다.
- **워크플로우:**
  1. 개발자는 중앙 Proto 리포지토리에서 `.proto` 파일을 수정합니다.
  2. 변경 사항이 `main` 브랜치에 머지되면, **CI/CD 파이프라인**이 자동으로 실행됩니다.
  3. CI는 `.proto` 파일로부터 각 언어(Go, Java 등)에 맞는 gRPC 클라이언트/서버 코드를 **자동으로 생성**합니다.
  4. 생성된 코드는 버전 태그(예: `v1.2.0`)와 함께 별도의 패키지 리포지토리(예: `github.com/my-company/my-protos-go`)에 배포됩니다.
  5. 각 마이크로서비스는 `go.mod` 파일을 통해 필요한 버전의 API 클라이언트 패키지를 라이브러리처럼 가져와 사용합니다.
- **기대효과:** 서비스 간의 강한 결합을 방지하고, 치명적인 순환 의존성 문제를 원천적으로 차단하며, 명확한 API 버전 관리가 가능해집니다.

## 3. 데이터베이스 관리

마이크로서비스의 자율성과 독립성을 보장하기 위해 데이터베이스를 철저히 분리합니다.

### 3.1. 핵심 원칙: 서비스당 데이터베이스 (Database per Service)

- **각 마이크로서비스는 자신만의 데이터베이스(또는 스키마)를 소유하고 독점적으로 접근합니다.**
- **어떤 서비스도 다른 서비스의 데이터베이스에 직접 접근할 수 없습니다.** 데이터가 필요하면 반드시 해당 서비스가 제공하는 API를 통해 요청해야 합니다.
- **공유 데이터베이스(Shared Database)는 대표적인 안티 패턴**으로, 서비스 간의 강한 결합을 유발하여 마이크로서비스의 모든 장점을 상쇄시키므로 절대적으로 지양합니다.

### 3.2. 서비스 간 데이터 연동 및 관계 관리 전략

전통적인 데이터베이스의 외래 키(Foreign Key)와 조인(JOIN)은 애플리케이션 레벨의 패턴으로 대체됩니다.

- **API 조합 (API Composition):**
  - **설명:** 데이터를 조회할 때, 한 서비스가 다른 서비스의 API를 호출하여 필요한 정보를 가져와 조합하는 방식입니다.
  - **예시:** `Order-Service`가 주문 상세 정보를 반환하기 위해, 주문 정보에 포함된 `product_id`를 가지고 `Product-Service`의 API를 호출하여 상품명을 가져옵니다.
  - **적합한 경우:** 대부분의 실시간 데이터 조회 및 조인 요구사항에 적합합니다.
- **데이터 중복 및 이벤트 기반 동기화 (Data Duplication & Event-Driven Sync):**
  - **설명:** 성능 향상과 서비스 간 런타임 의존성 제거를 위해, 자주 필요하고 잘 변하지 않는 데이터를 자신의 데이터베이스에 복제하여 저장합니다. 원본 데이터가 변경되면 메시지 큐(Kafka 등)를 통해 이벤트를 받아 비동기적으로 동기화합니다.
  - **예시:** `Order-Service`가 주문 항목 테이블에 `product_id`뿐만 아니라 `product_name`도 함께 저장합니다. `Product-Service`에서 상품명이 변경되면 `ProductNameChanged` 이벤트를 발행하고, `Order-Service`가 이를 구독하여 자신의 데이터를 업데이트합니다.
  - **특징:** 최종 일관성(Eventual Consistency) 모델을 따릅니다.
- **사가 패턴 (Saga Pattern):**
  - **설명:** 여러 서비스에 걸쳐 분산 트랜잭션을 관리하기 위한 패턴입니다. 하나의 비즈니스 트랜잭션을 여러 개의 로컬 트랜잭션과 보상 트랜잭션(실패 시 롤백)의 연속으로 설계합니다.
  - **적합한 경우:** 주문, 결제, 재고 차감 등 여러 서비스에 걸쳐 데이터 일관성을 반드시 보장해야 하는 복잡한 쓰기 작업에 사용됩니다.

## 4. 특수 목적 트래픽 처리 (Handling Specialized Traffic)

모든 트래픽을 단일 API 게이트웨이로 처리하는 것은 비효율적이며 병목 현상을 유발할 수 있습니다.2 따라서 트래픽의 특성에 따라 진입점을 분리하고 전문화하는 전략을 사용합니다.3

### 4.1. 실시간 양방향 통신 (예: 채팅 시스템)

- **문제점:** 채팅과 같은 실시간 양방향 통신은 연결을 유지하는 WebSocket 프로토콜을 사용하므로, 요청-응답 기반의 무상태(Stateless) API 게이트웨이에는 적합하지 않습니다.
- **해결책: 특수 목적 'WebSocket 게이트웨이' 분리**
  - **구조:** 기존 API 게이트웨이와 별개로, WebSocket 연결 관리 및 메시지 라우팅만을 전담하는 게이트웨이를 추가로 구축합니다.
  - **인증 흐름:**
    1. 클라이언트는 먼저 **Main API Gateway**를 통해 로그인하여 인증 토큰(Access Token)을 받습니다.
    2. 이 토큰을 사용하여 Main API Gateway에 **'WebSocket 연결 티켓'** 발급을 요청합니다.
    3. 발급받은 일회성 티켓을 가지고 **WebSocket 게이트웨이**에 연결을 수립합니다.
  - **기대효과:** Main API Gateway는 본연의 역할에 집중하고, WebSocket 게이트웨이는 대규모 동시 연결 처리에 최적화하여 독립적으로 확장할 수 있습니다.

### 4.3. 트래픽 유형별 처리 전략 요약

| 구분               | 일반 API 요청               | 실시간 채팅                       |
| ------------------ | --------------------------- | --------------------------------- |
| **주요 통신 패턴** | 요청-응답 (동기)            | 양방향 스트리밍 (연결 유지)       |
| **권장 진입점**    | **Main API Gateway**        | **WebSocket Gateway** (특수 목적) |
| **핵심 기술**      | `net/http/httputil`, gRPC   | WebSocket, `goroutine`            |
| **특징**           | 인증/인가, 라우팅 중앙 처리 | 대규모 동시 연결 관리 최적화      |
